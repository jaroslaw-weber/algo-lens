import { Pointer2D } from "algo-lens-core"; // Import Pointer2D
import { StepLoggerV2 } from "../../core/StepLoggerV2"; // Import StepLoggerV2
// Removed ProblemState, asArray, as2dArray
import { PacificAtlanticInput } from "./types"; // Import PacificAtlanticInput

// Helper function to convert boolean grid to number grid for visualization
const booleanGridToNumber = (grid: boolean[][]): number[][] => {
  return grid.map(row => row.map(cell => (cell ? 1 : 0)));
};

// Helper function to format queue for visualization
const formatQueue = (queue: [number, number][]): string[] => {
  return queue.map(([r, c]) => `(${r},${c})`); // Format as (r,c) for clarity
};

/**
 * Implements the pacificAtlanticWaterFlow algorithm which finds the cells that can flow to both the Pacific and Atlantic oceans.
 * @param heights - The input 2D array of heights.
 * @returns The steps generated by StepLoggerV2.
 */
export function generateSteps(heights: number[][]) { // Renamed and Exported, Return type inferred
  const l = new StepLoggerV2(); // Instantiate StepLoggerV2

  if (!heights || heights.length === 0 || heights[0].length === 0) {
    // Corrected: Remove invalid { group: ... }
    l.array2d("heights", []);
    l.array("result", []);
    l.breakpoint(0); // Initial/Final state
    return l.getSteps();
  }

  const rows = heights.length;
  const cols = heights[0].length;
  const pacificQueue: [number, number][] = [];
  const atlanticQueue: [number, number][] = [];
  const pacificVisited: boolean[][] = Array.from({ length: rows }, () =>
    new Array(cols).fill(false)
  );
  const atlanticVisited: boolean[][] = Array.from({ length: rows }, () =>
    new Array(cols).fill(false)
  );
  const result: [number, number][] = []; // Keep using result for final output

  let currentBreakpoint = 0;

  // Log initial state
  // Corrected: Use object format for l.simple and remove invalid group arg
  l.simple({ rows: rows });
  l.simple({ cols: cols });
  // Corrected: Remove invalid { group: ... } and label properties from non-existent options object
  l.array2d("heights", heights);
  l.array2d("pacificReachable", booleanGridToNumber(pacificVisited));
  l.array2d("atlanticReachable", booleanGridToNumber(atlanticVisited));
  l.array("pacificQueue", formatQueue(pacificQueue));
  l.array("atlanticQueue", formatQueue(atlanticQueue));
  l.breakpoint(currentBreakpoint++); // Breakpoint 0

  // Add all cells on the Pacific coast to the queue
  const initialPacificCells: Pointer2D[] = []; // Store as Pointer2D
  for (let r = 0; r < rows; r++) {
    if (!pacificVisited[r][0]) {
        pacificQueue.push([r, 0]);
        pacificVisited[r][0] = true;
        initialPacificCells.push({ r, c: 0 });
    }
  }
  for (let c = 1; c < cols; c++) {
     if (!pacificVisited[0][c]) {
        pacificQueue.push([0, c]);
        pacificVisited[0][c] = true;
        initialPacificCells.push({ r: 0, c });
     }
  }

  // Log state after initializing Pacific queue/visited
  // Corrected: Pass single Pointer2D or undefined, remove invalid group/label
  l.array2d("pacificReachable", booleanGridToNumber(pacificVisited), initialPacificCells[0]); // Pass first highlight if exists
  l.array("pacificQueue", formatQueue(pacificQueue));
  l.array2d("heights", heights); // Optionally show heights again
  l.breakpoint(currentBreakpoint++); // Breakpoint 1

  // --- Perform BFS from the Pacific coast ---
  let pacificStepCounter = 0;
  while (pacificQueue.length > 0) {
    const [r, c] = pacificQueue.shift()!;
    // Corrected: Use object format for l.simple and remove invalid group arg
    l.simple({ r: r });
    l.simple({ c: c });

    const neighborsVisited: Pointer2D[] = []; // Store as Pointer2D
    const currentCellHighlight: Pointer2D = { r, c }; // Single Pointer2D

    for (const [dr, dc] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
      const nr = r + dr;
      const nc = c + dc;
      // Corrected: Use object format for l.simple and remove invalid group arg
      l.simple({ nr: nr });
      l.simple({ nc: nc });

      if (
        nr >= 0 && nr < rows && nc >= 0 && nc < cols &&
        !pacificVisited[nr][nc] && heights[nr][nc] >= heights[r][c]
      ) {
        pacificVisited[nr][nc] = true;
        pacificQueue.push([nr, nc]);
        neighborsVisited.push({ r: nr, c: nc });
      }
    }

    // Log state after processing neighbors for cell [r, c]
    // Corrected: Pass single Pointer2D or undefined, remove invalid group/label
    l.array2d("heights", heights, currentCellHighlight, neighborsVisited[0]); // Pass current and first neighbor highlight
    l.array2d("pacificReachable", booleanGridToNumber(pacificVisited), currentCellHighlight, neighborsVisited[0]);
    l.array("pacificQueue", formatQueue(pacificQueue));
    // Reset neighbor indices?
    // Corrected: Use object format for l.simple and remove invalid group arg
    l.simple({ nr: undefined });
    l.simple({ nc: undefined });
    l.breakpoint(currentBreakpoint++); // Breakpoint inside Pacific BFS loop

    pacificStepCounter++;
  }
  // Reset r/c after loop
  // Corrected: Use object format for l.simple and remove invalid group arg
  l.simple({ r: undefined });
  l.simple({ c: undefined });

  // --- Add all cells on the Atlantic coast to the queue ---
  const initialAtlanticCells: Pointer2D[] = []; // Store as Pointer2D
   for (let r = 0; r < rows; r++) {
     if (!atlanticVisited[r][cols - 1]) {
        atlanticQueue.push([r, cols - 1]);
        atlanticVisited[r][cols - 1] = true;
        initialAtlanticCells.push({ r, c: cols - 1 });
     }
   }
   for (let c = 0; c < cols - 1; c++) {
     if (!atlanticVisited[rows - 1][c]) {
        atlanticQueue.push([rows - 1, c]);
        atlanticVisited[rows - 1][c] = true;
        initialAtlanticCells.push({ r: rows - 1, c });
     }
   }

  // Log state after initializing Atlantic queue/visited
  // Corrected: Pass single Pointer2D or undefined, remove invalid group/label
  l.array2d("atlanticReachable", booleanGridToNumber(atlanticVisited), initialAtlanticCells[0]); // Pass first highlight
  l.array("atlanticQueue", formatQueue(atlanticQueue));
  l.array2d("pacificReachable", booleanGridToNumber(pacificVisited)); // Show final pacific state
  l.breakpoint(currentBreakpoint++);

  // --- Perform BFS from the Atlantic coast ---
  let atlanticStepCounter = 0;
  while (atlanticQueue.length > 0) {
    const [r, c] = atlanticQueue.shift()!;
    // Corrected: Use object format for l.simple and remove invalid group arg
    l.simple({ r: r });
    l.simple({ c: c });

    const neighborsVisited: Pointer2D[] = []; // Store as Pointer2D
    const currentCellHighlight: Pointer2D = { r, c }; // Single Pointer2D

    for (const [dr, dc] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
      const nr = r + dr;
      const nc = c + dc;
      // Corrected: Use object format for l.simple and remove invalid group arg
      l.simple({ nr: nr });
      l.simple({ nc: nc });

      if (
        nr >= 0 && nr < rows && nc >= 0 && nc < cols &&
        !atlanticVisited[nr][nc] && heights[nr][nc] >= heights[r][c]
      ) {
        atlanticVisited[nr][nc] = true;
        atlanticQueue.push([nr, nc]);
        neighborsVisited.push({ r: nr, c: nc });
      }
    }

    // Log state after processing neighbors for cell [r, c]
    // Corrected: Pass single Pointer2D or undefined, remove invalid group/label
    l.array2d("heights", heights, currentCellHighlight, neighborsVisited[0]); // Pass current and first neighbor
    l.array2d("atlanticReachable", booleanGridToNumber(atlanticVisited), currentCellHighlight, neighborsVisited[0]);
    l.array("atlanticQueue", formatQueue(atlanticQueue));
    // Reset neighbor indices?
    // Corrected: Use object format for l.simple and remove invalid group arg
    l.simple({ nr: undefined });
    l.simple({ nc: undefined });
    l.breakpoint(currentBreakpoint++); // Breakpoint inside Atlantic BFS loop

    atlanticStepCounter++;
  }
   // Reset r/c after loop
   // Corrected: Use object format for l.simple and remove invalid group arg
   l.simple({ r: undefined });
   l.simple({ c: undefined });


  // --- Find the cells that can flow to both oceans ---
  const resultCellsHighlight: Pointer2D[] = []; // Store as Pointer2D
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (pacificVisited[r][c] && atlanticVisited[r][c]) {
        result.push([r, c]);
        resultCellsHighlight.push({ r, c });
      }
    }
  }

  // Log final state including the result
  // Corrected: Pass single Pointer2D or undefined, remove invalid group/label
  l.array2d("heights", heights, resultCellsHighlight[0]); // Pass first result highlight
  l.array2d("pacificReachable", booleanGridToNumber(pacificVisited), resultCellsHighlight[0]);
  l.array2d("atlanticReachable", booleanGridToNumber(atlanticVisited), resultCellsHighlight[0]);
  l.array("result", result); // Log the result array directly
  l.breakpoint(currentBreakpoint++); // Final breakpoint

  return l.getSteps(); // Return the collected steps
}
