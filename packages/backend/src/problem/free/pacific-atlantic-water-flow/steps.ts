import { Pointer2D } from "algo-lens-core"; // Import Pointer2D
import { StepLoggerV2 } from "../../core/StepLoggerV2"; // Import StepLoggerV2
// Removed ProblemState, asArray, as2dArray
import { PacificAtlanticInput } from "./types"; // Import PacificAtlanticInput

// Helper function to convert boolean grid to number grid for visualization
const booleanGridToNumber = (grid: boolean[][]): number[][] => {
  return grid.map((row) => row.map((cell) => (cell ? 1 : 0)));
};

// Helper function to format queue for visualization
const formatQueue = (queue: [number, number][]): string[] => {
  return queue.map(([r, c]) => `(${r},${c})`); // Format as (r,c) for clarity
};

/**
 * Implements the pacificAtlanticWaterFlow algorithm which finds the cells that can flow to both the Pacific and Atlantic oceans.
 * @param heights - The input 2D array of heights.
 * @returns The steps generated by StepLoggerV2.
 */
export function generateSteps(heights: number[][]) {
  // Renamed and Exported, Return type inferred
  const l = new StepLoggerV2(); // Instantiate StepLoggerV2

  if (!heights || heights.length === 0 || heights[0].length === 0) {
    // Corrected: Remove invalid { group: ... }
    l.grid("heights", []); // Replaced l.array2d with l.grid
    l.arrayV2({ result: [] }); // Replaced l.array with l.arrayV2
    l.breakpoint(1); // Initial state
    return l.getSteps();
  }

  const rows = heights.length;
  const cols = heights[0].length;
  const pacificQueue: [number, number][] = [];
  const atlanticQueue: [number, number][] = [];
  const pacificVisited: boolean[][] = Array.from({ length: rows }, () =>
    new Array(cols).fill(false)
  );
  const atlanticVisited: boolean[][] = Array.from({ length: rows }, () =>
    new Array(cols).fill(false)
  );
  const result: [number, number][] = []; // Keep using result for final output

  l.groupOptions.set("size", {min:0,max:Math.max(cols, rows)});
  l.groupOptions.set("pointers", {min:0, max:Math.max(cols, rows)});
  l.group("size", { cols, rows });
  // Corrected: Remove invalid { group: ... } and label properties from non-existent options object
  l.grid("heights", heights); // Replaced l.array2d with l.grid
  l.grid("pacificReachable", booleanGridToNumber(pacificVisited)); // Replaced l.array2d with l.grid
  l.grid("atlanticReachable", booleanGridToNumber(atlanticVisited)); // Replaced l.array2d with l.grid
  l.arrayV2({ pacificQueue: formatQueue(pacificQueue) }); // Replaced l.array with l.arrayV2
  l.arrayV2({ atlanticQueue: formatQueue(atlanticQueue) }); // Replaced l.array with l.arrayV2
  l.comment =
    "Initialize the state with the heights grid, two boolean grids to track cells reachable by the Pacific and Atlantic oceans (initially all false), and two empty queues for BFS traversal starting from the coasts.";
  l.breakpoint(2); // Initialize state

  // Add all cells on the Pacific coast to the queue
  const initialPacificCells: Pointer2D[] = []; // Store as Pointer2D
  for (let r = 0; r < rows; r++) {
    if (!pacificVisited[r][0]) {
      pacificQueue.push([r, 0]);
      pacificVisited[r][0] = true;
      initialPacificCells.push({ r, c: 0 });
    }
  }
  for (let c = 1; c < cols; c++) {
    if (!pacificVisited[0][c]) {
      pacificQueue.push([0, c]);
      pacificVisited[0][c] = true;
      initialPacificCells.push({ r: 0, c });
    }
  }

  // Log state after initializing Pacific queue/visited
  // Corrected: Pass single Pointer2D or undefined, remove invalid group/label
  l.grid(
    "pacificReachable",
    booleanGridToNumber(pacificVisited),
    initialPacificCells[0]
  ); // Replaced l.array2d with l.grid, Pass first highlight if exists
  l.arrayV2({ pacificQueue: formatQueue(pacificQueue) }); // Replaced l.array with l.arrayV2
  l.grid("heights", heights); // Replaced l.array2d with l.grid, Optionally show heights again
  l.comment =
    "Identify and add all cells on the Pacific coast (top row and leftmost column) to the Pacific queue. Mark these cells as reachable by the Pacific ocean in the pacificReachable grid. These coastal cells are the starting points for the BFS to find all cells that can flow to the Pacific.";
  l.breakpoint(3); // Initialize Pacific queue/visited

  // --- Perform BFS from the Pacific coast ---
  let pacificStepCounter = 0;
  while (pacificQueue.length > 0) {
    const [r, c] = pacificQueue.shift()!;

    l.group("pointers", { r, c });

    const neighborsVisited: Pointer2D[] = []; // Store as Pointer2D
    const currentCellHighlight: Pointer2D = { r, c }; // Single Pointer2D

    for (const [dr, dc] of [
      [-1, 0],
      [1, 0],
      [0, -1],
      [0, 1],
    ]) {
      const nr = r + dr;
      const nc = c + dc;

      l.group("pointers", { r, c, nr, nc });

      if (
        nr >= 0 &&
        nr < rows &&
        nc >= 0 &&
        nc < cols &&
        !pacificVisited[nr][nc] &&
        heights[nr][nc] >= heights[r][c]
      ) {
        pacificVisited[nr][nc] = true;
        pacificQueue.push([nr, nc]);
        neighborsVisited.push({ r: nr, c: nc });
      }
    }

    // Log state after processing neighbors for cell [r, c]
    // Corrected: Pass single Pointer2D or undefined, remove invalid group/label
    l.grid("heights", heights, currentCellHighlight, neighborsVisited[0]); // Replaced l.array2d with l.grid, Pass current and first neighbor highlight
    l.grid(
      "pacificReachable",
      booleanGridToNumber(pacificVisited),
      currentCellHighlight,
      neighborsVisited[0]
    ); // Replaced l.array2d with l.grid
    l.arrayV2({ pacificQueue: formatQueue(pacificQueue) }); // Replaced l.array with l.arrayV2
    // Reset neighbor indices?
    // Corrected: Use object format for l.simple and remove invalid group arg

    l.comment = `Process the cell (${r}, ${c}) from the front of the Pacific queue. Explore its adjacent neighbors. If a neighbor is within bounds, has not been visited by the Pacific BFS, and its height is greater than or equal to the current cell's height (allowing water to flow), add it to the Pacific queue and mark it as reachable by the Pacific. Update the pacificReachable grid and the pacificQueue.`;
    l.breakpoint(4); // Breakpoint inside Pacific BFS loop

    pacificStepCounter++;
  }
  l.hide("pointers");

  // --- Add all cells on the Atlantic coast to the queue ---
  const initialAtlanticCells: Pointer2D[] = []; // Store as Pointer2D
  for (let r = 0; r < rows; r++) {
    if (!atlanticVisited[r][cols - 1]) {
      atlanticQueue.push([r, cols - 1]);
      atlanticVisited[r][cols - 1] = true;
      initialAtlanticCells.push({ r, c: cols - 1 });
    }
  }
  for (let c = 0; c < cols - 1; c++) {
    if (!atlanticVisited[rows - 1][c]) {
      atlanticQueue.push([rows - 1, c]);
      atlanticVisited[rows - 1][c] = true;
      initialAtlanticCells.push({ r: rows - 1, c });
    }
  }

  // Log state after initializing Atlantic queue/visited
  // Corrected: Pass single Pointer2D or undefined, remove invalid group/label
  l.grid(
    "atlanticReachable",
    booleanGridToNumber(atlanticVisited),
    initialAtlanticCells[0]
  ); // Replaced l.array2d with l.grid, Pass first highlight
  l.arrayV2({ atlanticQueue: formatQueue(atlanticQueue) }); // Replaced l.array with l.arrayV2
  l.grid("pacificReachable", booleanGridToNumber(pacificVisited)); // Replaced l.array2d with l.grid, Show final pacific state
  l.comment =
    "Identify and add all cells on the Atlantic coast (bottom row and rightmost column) to the Atlantic queue. Mark these cells as reachable by the Atlantic ocean in the atlanticReachable grid. These coastal cells are the starting points for the BFS to find all cells that can flow to the Atlantic.";
  l.breakpoint(5); // Initialize Atlantic queue/visited

  // --- Perform BFS from the Atlantic coast ---
  let atlanticStepCounter = 0;
  while (atlanticQueue.length > 0) {
    const [r, c] = atlanticQueue.shift()!;

    l.group("pointers", { r, c });

    const neighborsVisited: Pointer2D[] = []; // Store as Pointer2D
    const currentCellHighlight: Pointer2D = { r, c }; // Single Pointer2D

    for (const [dr, dc] of [
      [-1, 0],
      [1, 0],
      [0, -1],
      [0, 1],
    ]) {
      const nr = r + dr;
      const nc = c + dc;
      // Corrected: Use object format for l.simple and remove invalid group arg

      l.group("pointers", { r, c, nr, nc });

      if (
        nr >= 0 &&
        nr < rows &&
        nc >= 0 &&
        nc < cols &&
        !atlanticVisited[nr][nc] &&
        heights[nr][nc] >= heights[r][c]
      ) {
        atlanticVisited[nr][nc] = true;
        atlanticQueue.push([nr, nc]);
        neighborsVisited.push({ r: nr, c: nc });
      }
    }

    // Log state after processing neighbors for cell [r, c]
    // Corrected: Pass single Pointer2D or undefined, remove invalid group/label
    l.grid("heights", heights, currentCellHighlight, neighborsVisited[0]); // Replaced l.array2d with l.grid, Pass current and first neighbor
    l.grid(
      "atlanticReachable",
      booleanGridToNumber(atlanticVisited),
      currentCellHighlight,
      neighborsVisited[0]
    ); // Replaced l.array2d with l.grid
    l.arrayV2({ atlanticQueue: formatQueue(atlanticQueue) }); // Replaced l.array with l.arrayV2
    // Reset neighbor indices?
    // Corrected: Use object format for l.simple and remove invalid group arg

    l.comment = `Process the cell (${r}, ${c}) from the front of the Atlantic queue. Explore its adjacent neighbors. If a neighbor is within bounds, has not been visited by the Atlantic BFS, and its height is greater than or equal to the current cell's height (allowing water to flow), add it to the Atlantic queue and mark it as reachable by the Atlantic. Update the atlanticReachable grid and the atlanticQueue.`;
    l.breakpoint(6); // Breakpoint inside Atlantic BFS loop

    atlanticStepCounter++;
  }
  l.hide("pointers");

  // --- Find the cells that can flow to both oceans ---
  const resultCellsHighlight: Pointer2D[] = []; // Store as Pointer2D
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      if (pacificVisited[r][c] && atlanticVisited[r][c]) {
        result.push([r, c]);
        resultCellsHighlight.push({ r, c });
      }
    }
  }

  // Log final state including the result
  // Corrected: Pass single Pointer2D or undefined, remove invalid group/label
  l.grid("heights", heights, resultCellsHighlight[0]); // Replaced l.array2d with l.grid, Pass first result highlight
  l.grid(
    "pacificReachable",
    booleanGridToNumber(pacificVisited),
    resultCellsHighlight[0]
  ); // Replaced l.array2d with l.grid
  l.grid(
    "atlanticReachable",
    booleanGridToNumber(atlanticVisited),
    resultCellsHighlight[0]
  ); // Replaced l.array2d with l.grid
  l.arrayV2({ result: result }); // Replaced l.array with l.arrayV2, Log the result array directly
  l.comment =
    "After completing BFS from both the Pacific and Atlantic coasts, iterate through all cells in the grid. If a cell is marked as reachable by *both* the Pacific and Atlantic oceans, it means water can flow from this cell to both oceans. Collect these cells as the final result.";
  l.breakpoint(7); // Final breakpoint

  return l.getSteps(); // Return the collected steps
}
