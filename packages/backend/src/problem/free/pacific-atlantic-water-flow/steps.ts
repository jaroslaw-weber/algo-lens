import { StepLoggerV2 } from "../../core/StepLoggerV2"; // Import StepLoggerV2
// Removed ProblemState, asArray, as2dArray
import { PacificAtlanticInput } from "./types"; // Import PacificAtlanticInput

// Helper function to convert boolean grid to number grid for visualization
const booleanGridToNumber = (grid: boolean[][]): number[][] => {
  return grid.map(row => row.map(cell => (cell ? 1 : 0)));
};

// Helper function to format queue for visualization
const formatQueue = (queue: [number, number][]): string[] => {
  return queue.map(([r, c]) => `${r},${c}`);
};

/**
 * Implements the pacificAtlanticWaterFlow algorithm which finds the cells that can flow to both the Pacific and Atlantic oceans.
 * @param heights - The input 2D array of heights.
 * @returns The steps generated by StepLoggerV2.
 */
export function generateSteps(heights: number[][]) { // Renamed and Exported, Return type inferred
  const l = new StepLoggerV2(); // Instantiate StepLoggerV2

  if (!heights || heights.length === 0 || heights[0].length === 0) {
    l.array2d("heights", [], undefined, { group: "input" });
    l.array("result", [], undefined, { group: "result" });
    l.breakpoint(0); // Initial/Final state
    return l.getSteps();
  }

  const rows = heights.length;
  const cols = heights[0].length;
  const pacificQueue: [number, number][] = [];
  const atlanticQueue: [number, number][] = [];
  const pacificVisited: boolean[][] = Array.from({ length: rows }, () =>
    new Array(cols).fill(false)
  );
  const atlanticVisited: boolean[][] = Array.from({ length: rows }, () =>
    new Array(cols).fill(false)
  );
  const result: [number, number][] = []; // Keep using result for final output

  let currentBreakpoint = 0;

  // Log initial state
  l.simple("rows", rows, { group: "input" });
  l.simple("cols", cols, { group: "input" });
  l.array2d("heights", heights, undefined, { group: "input" });
  l.array2d("pacificReachable", booleanGridToNumber(pacificVisited), undefined, { group: "state", label: "Pacific Reachable (0=false, 1=true)" });
  l.array2d("atlanticReachable", booleanGridToNumber(atlanticVisited), undefined, { group: "state", label: "Atlantic Reachable (0=false, 1=true)" });
  l.array("pacificQueue", formatQueue(pacificQueue), undefined, { group: "pacificBFS" });
  l.array("atlanticQueue", formatQueue(atlanticQueue), undefined, { group: "atlanticBFS" });
  l.breakpoint(currentBreakpoint++); // Breakpoint 0

  // Add all cells on the Pacific coast to the queue
  const initialPacificCells: { r: number, c: number }[] = [];
  for (let r = 0; r < rows; r++) {
    if (!pacificVisited[r][0]) {
        pacificQueue.push([r, 0]);
        pacificVisited[r][0] = true;
        initialPacificCells.push({ r, c: 0 });
    }
  }
  for (let c = 1; c < cols; c++) {
     if (!pacificVisited[0][c]) {
        pacificQueue.push([0, c]);
        pacificVisited[0][c] = true;
        initialPacificCells.push({ r: 0, c });
     }
  }

  // Log state after initializing Pacific queue/visited
  l.array2d("pacificReachable", booleanGridToNumber(pacificVisited), initialPacificCells, { group: "state", label: "Pacific Reachable (0=false, 1=true)" });
  l.array("pacificQueue", formatQueue(pacificQueue), undefined, { group: "pacificBFS" });
  l.array2d("heights", heights, undefined, { group: "input" }); // Optionally show heights again
  l.breakpoint(currentBreakpoint++); // Breakpoint 1

  // --- Perform BFS from the Pacific coast ---
  let pacificStepCounter = 0; // To potentially limit steps inside BFS if needed
  while (pacificQueue.length > 0) {
    const [r, c] = pacificQueue.shift()!; // Non-null assertion as we check length > 0
    l.simple("r", r, { group: "pacificBFS" });
    l.simple("c", c, { group: "pacificBFS" });

    const neighborsVisited: { r: number, c: number }[] = [];
    const currentCellHighlight = [{ r, c }];

    for (const [dr, dc] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
      const nr = r + dr;
      const nc = c + dc;
      l.simple("nr", nr, { group: "pacificBFS" });
      l.simple("nc", nc, { group: "pacificBFS" });

      if (
        nr >= 0 && nr < rows && nc >= 0 && nc < cols &&
        !pacificVisited[nr][nc] && heights[nr][nc] >= heights[r][c]
      ) {
        pacificVisited[nr][nc] = true;
        pacificQueue.push([nr, nc]);
        neighborsVisited.push({ r: nr, c: nc });
      }
       // Log state change *after* checking each neighbor? Or after processing all neighbors? Let's log after all neighbors.
       // l.breakpoint(currentBreakpoint++); // Potential breakpoint after each neighbor check
    }

    // Log state after processing neighbors for cell [r, c]
    l.array2d("heights", heights, [...currentCellHighlight, ...neighborsVisited], { group: "input" });
    l.array2d("pacificReachable", booleanGridToNumber(pacificVisited), [...currentCellHighlight, ...neighborsVisited], { group: "state", label: "Pacific Reachable (0=false, 1=true)" });
    l.array("pacificQueue", formatQueue(pacificQueue), undefined, { group: "pacificBFS" });
    // Reset neighbor indices?
    l.simple("nr", undefined, { group: "pacificBFS" });
    l.simple("nc", undefined, { group: "pacificBFS" });
    l.breakpoint(currentBreakpoint++); // Breakpoint inside Pacific BFS loop

    pacificStepCounter++;
    // Optional: Add a check to limit steps if BFS becomes too long for visualization
    // if (pacificStepCounter > MAX_BFS_STEPS) break;
  }
  // Reset r/c after loop
  l.simple("r", undefined, { group: "pacificBFS" });
  l.simple("c", undefined, { group: "pacificBFS" });

  // --- Add all cells on the Atlantic coast to the queue ---
  const initialAtlanticCells: { r: number, c: number }[] = [];
   for (let r = 0; r < rows; r++) {
     if (!atlanticVisited[r][cols - 1]) {
        atlanticQueue.push([r, cols - 1]);
        atlanticVisited[r][cols - 1] = true;
        initialAtlanticCells.push({ r, c: cols - 1 });
     }
   }
   for (let c = 0; c < cols - 1; c++) {
     if (!atlanticVisited[rows - 1][c]) {
        atlanticQueue.push([rows - 1, c]);
        atlanticVisited[rows - 1][c] = true;
        initialAtlanticCells.push({ r: rows - 1, c });
     }
   }

  // Log state after initializing Atlantic queue/visited
  l.array2d("atlanticReachable", booleanGridToNumber(atlanticVisited), initialAtlanticCells, { group: "state", label: "Atlantic Reachable (0=false, 1=true)" });
  l.array("atlanticQueue", formatQueue(atlanticQueue), undefined, { group: "atlanticBFS" });
  l.array2d("pacificReachable", booleanGridToNumber(pacificVisited), undefined, { group: "state", label: "Pacific Reachable (0=false, 1=true)" }); // Show final pacific state
  l.breakpoint(currentBreakpoint++);

  // --- Perform BFS from the Atlantic coast ---
  let atlanticStepCounter = 0;
  while (atlanticQueue.length > 0) {
    const [r, c] = atlanticQueue.shift()!;
    l.simple("r", r, { group: "atlanticBFS" });
    l.simple("c", c, { group: "atlanticBFS" });

    const neighborsVisited: { r: number, c: number }[] = [];
    const currentCellHighlight = [{ r, c }];

    for (const [dr, dc] of [[-1, 0], [1, 0], [0, -1], [0, 1]]) {
      const nr = r + dr;
      const nc = c + dc;
      l.simple("nr", nr, { group: "atlanticBFS" });
      l.simple("nc", nc, { group: "atlanticBFS" });

      if (
        nr >= 0 && nr < rows && nc >= 0 && nc < cols &&
        !atlanticVisited[nr][nc] && heights[nr][nc] >= heights[r][c]
      ) {
        atlanticVisited[nr][nc] = true;
        atlanticQueue.push([nr, nc]);
        neighborsVisited.push({ r: nr, c: nc });
      }
       // l.breakpoint(currentBreakpoint++); // Potential breakpoint after each neighbor check
    }

    // Log state after processing neighbors for cell [r, c]
    l.array2d("heights", heights, [...currentCellHighlight, ...neighborsVisited], { group: "input" });
    l.array2d("atlanticReachable", booleanGridToNumber(atlanticVisited), [...currentCellHighlight, ...neighborsVisited], { group: "state", label: "Atlantic Reachable (0=false, 1=true)" });
    l.array("atlanticQueue", formatQueue(atlanticQueue), undefined, { group: "atlanticBFS" });
    // Reset neighbor indices?
    l.simple("nr", undefined, { group: "atlanticBFS" });
    l.simple("nc", undefined, { group: "atlanticBFS" });
    l.breakpoint(currentBreakpoint++); // Breakpoint inside Atlantic BFS loop

    atlanticStepCounter++;
    // if (atlanticStepCounter > MAX_BFS_STEPS) break;
  }
   // Reset r/c after loop
   l.simple("r", undefined, { group: "atlanticBFS" });
   l.simple("c", undefined, { group: "atlanticBFS" });


  // --- Find the cells that can flow to both oceans ---
  const resultCellsHighlight: { r: number, c: number }[] = [];
  for (let r = 0; r < rows; r++) {
    for (let c = 0; c < cols; c++) {
      // Check if the cell is reachable from both oceans
      if (pacificVisited[r][c] && atlanticVisited[r][c]) { // Corrected typo: j -> c
        result.push([r, c]);
        resultCellsHighlight.push({ r, c });
      }
    }
  }

  // Log final state including the result
  l.array2d("heights", heights, resultCellsHighlight, { group: "input" });
  l.array2d("pacificReachable", booleanGridToNumber(pacificVisited), resultCellsHighlight, { group: "state", label: "Pacific Reachable (0=false, 1=true)" });
  l.array2d("atlanticReachable", booleanGridToNumber(atlanticVisited), resultCellsHighlight, { group: "state", label: "Atlantic Reachable (0=false, 1=true)" });
  l.array("result", formatQueue(result), undefined, { group: "result" }); // Use formatQueue for consistency
  l.breakpoint(currentBreakpoint++); // Final breakpoint

  return l.getSteps(); // Return the collected steps
}

// Removed code, title, getInput, Problem export comment might be outdated.
