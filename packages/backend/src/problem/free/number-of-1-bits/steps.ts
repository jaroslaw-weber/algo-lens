import { ProblemState } from "algo-lens-core";
import { StepLoggerV2 } from "../../core/StepLoggerV2"; // Import StepLoggerV2
import { HammingWeightInput } from "./types";

export function generateSteps(p: HammingWeightInput): ProblemState[] {
  const { n } = p;
  const l = new StepLoggerV2(); // Instantiate StepLoggerV2
  l.groupOptions.set("input", {
    min: 0,
    max: n,
  });
  l.groupOptions.set("count", {
    min: 0,
    max: n,
  });

  let count = 0;
  let maskingBit = 1;
  let i = 0;

  // Initial state log
  l.group("input", { n }); // Log initial input 'n'
  l.binary({ n }, { pointersRight: [i] }); // Log 'n' in binary with pointer
  l.binary({ maskingBit }, { pointersLeft: [0] }); // Log 'maskingBit' in binary with pointer
  l.group("count", { count }); // Log initial 'count'
  l.breakpoint(1);

  //#2 Start the loop to count the number of 1-bits
  while (maskingBit <= n) {
    l.breakpoint(2);

    //#3 Check if the least significant bit is 1
    if (n & maskingBit) {
      count++;
      l.group("count", { count }); // Update count display
      l.breakpoint(3);
    }

    //#4 Shift the masking bit to the left (corrected from right in comments)
    maskingBit <<= 1;
    i++;
    l.binary({ n }, { pointersRight: [i] }); // Update 'n' pointer
    l.binary({ maskingBit }, { pointersLeft: [0] }); // Update 'maskingBit' value and pointer
    l.breakpoint(4);
  }

  l.breakpoint(5); // Mark the end of calculation

  // Explicitly log the final count with the label 'result'
  l.group("result", { result: count }); // Use the final value of count
  l.breakpoint(6); // Optional: Add a final breakpoint for the result state

  //#5 Return the steps generated by StepLoggerV2
  return l.getSteps();
}
