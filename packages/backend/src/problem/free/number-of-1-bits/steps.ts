import { ProblemState } from "algo-lens-core";
import { StepLoggerV2 } from "../../core/StepLoggerV2"; // Import StepLoggerV2
import { HammingWeightInput } from "./types";

export function generateSteps(n: number): ProblemState[] {
  const l = new StepLoggerV2(); // Instantiate StepLoggerV2

  l.groupOptions.set("count", {
    min: 0,
    max: n,
  });

  let count = 0;
  let maskingBit = 1;
  let i = 0;

  l.binary({ n }, { pointersRight: [i] }); // Log 'n' in binary with pointer
  l.binary({ maskingBit }, { pointersLeft: [0] }); // Log 'maskingBit' in binary with pointer
  l.group("count", { count }); // Log initial 'count'
  l.comment = `Initialize the count of 1-bits to 0. The maskingBit is set to 1 (binary 0...001) to check the least significant bit first. The variable i is initialized to 0 to track the bit position being checked. Current state: n = ${n}, maskingBit = ${maskingBit}, count = ${count}.`;
  l.breakpoint(1);

  //#2 Start the loop to count the number of 1-bits
  while (maskingBit <= n) {
    l.comment = `Enter the loop to check each bit of the number n. The loop continues as long as the maskingBit (${maskingBit}) is less than or equal to n (${n}), ensuring all relevant bits are examined.`;
    l.breakpoint(2);

    //#3 Check if the least significant bit is 1
    if (n & maskingBit) {
      count++;
      l.group("count", { count }); // Update count display
      l.comment = `Perform a bitwise AND operation between n (${n}) and maskingBit (${maskingBit}). If the result is non-zero (true), it means the bit at the current position in n is 1. Since the bit is 1, increment the count of 1-bits to ${count}.`;
      l.breakpoint(3);
    }

    //#4 Shift the masking bit to the left (corrected from right in comments)
    maskingBit <<= 1;
    i++;
    l.binary({ n }, { pointersRight: [i] }); // Update 'n' pointer
    l.binary({ maskingBit }, { pointersLeft: [0] }); // Update 'maskingBit' value and pointer
    l.comment = `Shift the maskingBit to the left by one position (maskingBit <<= 1). This prepares the maskingBit to check the next bit position in n. Increment i to ${i} to reflect the move to the next bit position. New maskingBit = ${maskingBit}.`;
    l.breakpoint(4);
  }
  const result = count; // Store the final result
  l.simple({ result }); // Use the final value of count
  l.comment = `The loop has finished checking all the bits. The final count of 1-bits in the number n is ${result}.`;
  l.breakpoint(5); // Added final breakpoint

  //#5 Return the steps generated by StepLoggerV2
  return l.getSteps();
}
